
# üå≥ Exerc√≠cios ‚Äì Inser√ß√£o, Busca e Percursos em √Årvores Bin√°rias de Busca (ABB)

## ‚úÖ Quest√£o (a) ‚Äì Inser√ß√£o de um elemento na √°rvore

### O que √©?
Inserir um novo valor seguindo a regra da ABB:

- Se o valor for **menor que o n√≥ atual**, vai para a esquerda.
- Se for **maior**, vai para a direita.
- A inser√ß√£o √© feita de forma recursiva.

### Exemplo de inser√ß√£o:
Inserindo os valores na ordem: **30, 20, 40, 10, 25**

**Resultado da √°rvore:**

```
        30
       /  \
     20    40
    /  \
  10   25
```

---

## ‚úÖ Quest√£o (c) ‚Äì Pesquisa (busca) de um valor

### O que √©?
Procurar se um valor existe na √°rvore.

### Como funciona?
- Come√ßa na raiz.
- Se o valor for igual ao n√≥ ‚Üí **encontrou!**
- Se for menor ‚Üí busca na **esquerda**.
- Se for maior ‚Üí busca na **direita**.
- Se chegar em NULL ‚Üí o valor **n√£o existe na √°rvore**.

### Exemplo de busca:
Buscar o valor **25** na √°rvore acima:

- Come√ßa em 30 ‚Üí vai pra esquerda (20)
- Em 20 ‚Üí vai pra direita (25)
- **Achou!**

---

## ‚úÖ Quest√µes (g), (h), (i) ‚Äì Percursos (Pr√©, In, P√≥s-Ordem)

### Tipos de percurso:

| Tipo | Ordem de visita |
|---|---|
| **Pr√©-Ordem (g)** | Raiz ‚Üí Esquerda ‚Üí Direita |
| **In-Ordem (h)** | Esquerda ‚Üí Raiz ‚Üí Direita |
| **P√≥s-Ordem (i)** | Esquerda ‚Üí Direita ‚Üí Raiz |

### Exemplo pr√°tico com a √°rvore:

```
        30
       /  \
     20    40
    /  \
  10   25
```

| Tipo de Percurso | Resultado |
|---|---|
| Pr√©-Ordem | 30, 20, 10, 25, 40 |
| In-Ordem | 10, 20, 25, 30, 40 |
| P√≥s-Ordem | 10, 25, 20, 40, 30 |

---

## ‚úÖ C√≥digo completo em C para testar tudo:

```c
#include <stdio.h>
#include <stdlib.h>

// Estrutura do n√≥
typedef struct Node {
    int valor;
    struct Node* esquerda;
    struct Node* direita;
} Node;

// Fun√ß√£o para criar um novo n√≥
Node* criarNo(int valor) {
    Node* novo = (Node*)malloc(sizeof(Node));
    novo->valor = valor;
    novo->esquerda = NULL;
    novo->direita = NULL;
    return novo;
}

// Inser√ß√£o na ABB
Node* inserir(Node* raiz, int valor) {
    if (raiz == NULL)
        return criarNo(valor);

    if (valor < raiz->valor)
        raiz->esquerda = inserir(raiz->esquerda, valor);
    else if (valor > raiz->valor)
        raiz->direita = inserir(raiz->direita, valor);

    return raiz;
}

// Busca de um valor
int buscar(Node* raiz, int valor) {
    if (raiz == NULL)
        return 0;

    if (raiz->valor == valor)
        return 1;
    else if (valor < raiz->valor)
        return buscar(raiz->esquerda, valor);
    else
        return buscar(raiz->direita, valor);
}

// Percurso Pr√©-Ordem
void preOrdem(Node* raiz) {
    if (raiz != NULL) {
        printf("%d ", raiz->valor);
        preOrdem(raiz->esquerda);
        preOrdem(raiz->direita);
    }
}

// Percurso In-Ordem
void inOrdem(Node* raiz) {
    if (raiz != NULL) {
        inOrdem(raiz->esquerda);
        printf("%d ", raiz->valor);
        inOrdem(raiz->direita);
    }
}

// Percurso P√≥s-Ordem
void posOrdem(Node* raiz) {
    if (raiz != NULL) {
        posOrdem(raiz->esquerda);
        posOrdem(raiz->direita);
        printf("%d ", raiz->valor);
    }
}

// Fun√ß√£o principal
int main() {
    Node* raiz = NULL;

    // Inserindo valores
    int valores[] = {30, 20, 40, 10, 25};
    int n = sizeof(valores)/sizeof(valores[0]);
    for (int i = 0; i < n; i++) {
        raiz = inserir(raiz, valores[i]);
    }

    // Teste de busca
    int busca = 25;
    if (buscar(raiz, busca))
        printf("Valor %d encontrado na √°rvore!\n", busca);
    else
        printf("Valor %d N√ÉO encontrado na √°rvore!\n", busca);

    // Teste de percursos
    printf("Pr√©-Ordem: ");
    preOrdem(raiz);
    printf("\n");

    printf("In-Ordem: ");
    inOrdem(raiz);
    printf("\n");

    printf("P√≥s-Ordem: ");
    posOrdem(raiz);
    printf("\n");

    return 0;
}
```

---

## ‚úÖ O que o programa faz:

- **Insere** os elementos: 30, 20, 40, 10, 25.
- **Faz a busca** pelo valor 25.
- **Exibe os 3 percursos:** Pr√©, In e P√≥s-Ordem.
