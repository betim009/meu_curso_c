# C 01 — Explicações e Gabaritos (ex00–ex08)

> Materiais didáticos para quem está começando. Cada exercício
> traz: objetivo, explicação simples, gabarito (código completo)
> e um exemplo de teste **opcional** (não entregue). Sempre
> compile com:
>
> ```bash
> gcc -Wall -Wextra -Werror arquivo.c main.c -o a.out
> ```
>
> **Importante:** siga a Norm da 42. Use apenas o que o enunciado
> permite (nada de `stdio.h` onde não é pedido). Para imprimir,
> use `write` de `<unistd.h>` quando necessário.

---

## ex00 — `ft_ft`

**Protótipo:** `void ft_ft(int *nbr);`

**Objetivo:** colocar o valor `42` no endereço apontado por `nbr`.

**Por que isso?** Para entender como um ponteiro permite alterar
um valor fora da função.

### Gabarito
```c
// ex00/ft_ft.c
void	ft_ft(int *nbr)
{
	*nbr = 42;
}
```

### Teste rápido (opcional)
```c
// main.c (apenas para testar localmente)
#include <unistd.h>

void	ft_ft(int *nbr);

int	main(void)
{
	int x = 0;
	ft_ft(&x);
	// imprime "42\n"
	char buf[12];
	int n = 0;
	if (x >= 10) { buf[n++] = '0' + (x / 10); }
	buf[n++] = '0' + (x % 10);
	buf[n++] = '\n';
	write(1, buf, n);
	return 0;
}
```

**Erros comuns:** esquecer o `*` (desreferenciar) e tentar fazer
`nbr = 42;` (isso só muda a cópia do ponteiro, não o valor apontado).

---

## ex01 — `ft_ultimate_ft`

**Protótipo:** `void ft_ultimate_ft(int *********nbr);`

**Objetivo:** colocar `42` no inteiro no fim de **nove níveis** de
ponteiro.

**Ideia:** descer todas as camadas e atribuir no inteiro final.

### Gabarito
```c
// ex01/ft_ultimate_ft.c
void	ft_ultimate_ft(int *********nbr)
{
	*********nbr = 42;
}
```

**Erros comuns:** confundir o número de `*`. Siga exatamente
o protótipo.

---

## ex02 — `ft_swap`

**Protótipo:** `void ft_swap(int *a, int *b);`

**Objetivo:** trocar os valores apontados por `a` e `b`.

**Ideia:** usar uma variável temporária.

### Gabarito
```c
// ex02/ft_swap.c
void	ft_swap(int *a, int *b)
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}
```

**Erros comuns:** tentar trocar os ponteiros (endereços) em vez dos
valores. Lembre-se de usar `*a` e `*b`.

---

## ex03 — `ft_div_mod`

**Protótipo:** `void ft_div_mod(int a, int b, int *div, int *mod);`

**Objetivo:** colocar em `*div` o quociente de `a / b` e em `*mod`
`a % b`.

**Atenção:** o enunciado assume **b != 0**. Evite dividir por zero ao
 testar.

### Gabarito
```c
// ex03/ft_div_mod.c
void	ft_div_mod(int a, int b, int *div, int *mod)
{
	*div = a / b;
	*mod = a % b;
}
```

**Erros comuns:** calcular `a / b` e depois usar o resultado como
resto. O resto deve ser `a % b` com os **valores originais**.

---

## ex04 — `ft_ultimate_div_mod`

**Protótipo:** `void ft_ultimate_div_mod(int *a, int *b);`

**Objetivo:** colocar em `*a` o quociente de `*a / *b` e em `*b`
o resto dessa mesma divisão.

**Ideia:** guarde `*a` e `*b` antes de alterar para não perder dados.

### Gabarito
```c
// ex04/ft_ultimate_div_mod.c
void	ft_ultimate_div_mod(int *a, int *b)
{
	int x;
	int y;

	x = *a;
	y = *b;
	*a = x / y;
	*b = x % y;
}
```

**Erros comuns:** fazer primeiro `*a = *a / *b;` e depois usar `*a`
modificado para calcular o resto. Isso quebra o resultado.

---

## ex05 — `ft_putstr`

**Protótipo:** `void ft_putstr(char *str);`

**Funções permitidas:** `write` (precisa de `<unistd.h>`)

**Objetivo:** imprimir a string até `\0`.

### Gabarito
```c
// ex05/ft_putstr.c
#include <unistd.h>

void	ft_putstr(char *str)
{
	int i;

	i = 0;
	while (str[i] != '\0')
	{
		write(1, &str[i], 1);
		i++;
	}
}
```

**Erros comuns:** usar `printf` (não permitido) ou não parar no `\0`.

---

## ex06 — `ft_strlen`

**Protótipo:** `int ft_strlen(char *str);`

**Objetivo:** contar quantos caracteres existem antes do `\0`.

### Gabarito
```c
// ex06/ft_strlen.c
int	ft_strlen(char *str)
{
	int len;

	len = 0;
	while (str[len] != '\0')
		len++;
	return (len);
}
```

**Erros comuns:** iniciar `len` sem zero ou retornar `len + 1`.

---

## ex07 — `ft_rev_int_tab`

**Protótipo:** `void ft_rev_int_tab(int *tab, int size);`

**Objetivo:** inverter a ordem dos elementos do array `tab` in-place.

**Ideia:** dois índices, um no começo e outro no fim, trocando até se
cruzarem.

### Gabarito
```c
// ex07/ft_rev_int_tab.c
void	ft_rev_int_tab(int *tab, int size)
{
	int i;
	int j;
	int tmp;

	i = 0;
	j = size - 1;
	while (i < j)
	{
		tmp = tab[i];
		tab[i] = tab[j];
		tab[j] = tmp;
		i++;
		j--;
	}
}
```

**Erros comuns:** laço indo até `i <= j` (troca o elemento central
 duas vezes em tamanhos ímpares) ou esquecer de decrementar `j`.

---

## ex08 — `ft_sort_int_tab`

**Protótipo:** `void ft_sort_int_tab(int *tab, int size);`

**Objetivo:** ordenar o array de inteiros em ordem crescente.

**Estratégia simples (ok para a Piscine):** *bubble sort*.

### Gabarito
```c
// ex08/ft_sort_int_tab.c
void	ft_sort_int_tab(int *tab, int size)
{
	int i;
	int swapped;
	int tmp;

	if (size <= 1)
		return ;
	while (1)
	{
		swapped = 0;
		i = 0;
		while (i < size - 1)
		{
			if (tab[i] > tab[i + 1])
			{
				tmp = tab[i];
				tab[i] = tab[i + 1];
				tab[i + 1] = tmp;
				swapped = 1;
			}
			i++;
		}
		if (!swapped)
			break ;
	}
}
```

**Erros comuns:** confiar que `size` cabeçalho sempre é válido (teste
`size <= 1`) e esquecer de repetir as passagens até não haver trocas.

---

## Dicas finais

- Crie um `main.c` separado só para seus testes locais.
- Teste casos limite: `size = 0`, `size = 1`, strings vazias, números
  negativos etc.
- Revise identação, tabulações e nomes conforme a Norm da 42.
- Se o avaliador citar funções proibidas, remova qualquer `#include`
  desnecessário.

# C 01 — Explicações e Gabaritos (ex00–ex08)

> Materiais didáticos para quem está começando. Cada exercício
> traz: objetivo, explicação simples, gabarito (código completo)
> e uma seção **Como testar (opcional)** com `main_exXX.c`.
> Sempre compile com:
>
> ```bash
> gcc -Wall -Wextra -Werror arquivo.c main.c -o a.out
> ```
>
> **Importante:** siga a Norm da 42. Use apenas o que o enunciado
> permite (nada de `stdio.h` onde não é pedido). Para imprimir,
> use `write` de `<unistd.h>` quando necessário. **Não envie** os
> `main_exXX.c` — eles servem só para testar localmente.

---

## ex00 — `ft_ft`

**Protótipo:** `void ft_ft(int *nbr);`

**Objetivo:** colocar o valor `42` no endereço apontado por `nbr`.

**Por que isso?** Para entender como um ponteiro permite alterar
um valor fora da função.

### Gabarito
```c
// ex00/ft_ft.c
void	ft_ft(int *nbr)
{
	*nbr = 42;
}
```

**Erros comuns:** esquecer o `*` (desreferenciar) e tentar fazer
`nbr = 42;` (isso só muda a cópia do ponteiro, não o valor apontado).

---

## ex01 — `ft_ultimate_ft`

**Protótipo:** `void ft_ultimate_ft(int *********nbr);`

**Objetivo:** colocar `42` no inteiro no fim de **nove níveis** de
ponteiro.

**Ideia:** descer todas as camadas e atribuir no inteiro final.

### Gabarito
```c
// ex01/ft_ultimate_ft.c
void	ft_ultimate_ft(int *********nbr)
{
	*********nbr = 42;
}
```

**Erros comuns:** confundir o número de `*`. Siga exatamente
o protótipo.

---

## ex02 — `ft_swap`

**Protótipo:** `void ft_swap(int *a, int *b);`

**Objetivo:** trocar os valores apontados por `a` e `b`.

**Ideia:** usar uma variável temporária.

### Gabarito
```c
// ex02/ft_swap.c
void	ft_swap(int *a, int *b)
{
	int tmp;
	tmp = *a;
	*a = *b;
	*b = tmp;
}
```

**Erros comuns:** tentar trocar os ponteiros (endereços) em vez dos
valores. Lembre-se de usar `*a` e `*b`.

---

## ex03 — `ft_div_mod`

**Protótipo:** `void ft_div_mod(int a, int b, int *div, int *mod);`

**Objetivo:** colocar em `*div` o quociente de `a / b` e em `*mod`
`a % b`.

**Atenção:** o enunciado assume **b != 0**. Evite dividir por zero ao
 testar.

### Gabarito
```c
// ex03/ft_div_mod.c
void	ft_div_mod(int a, int b, int *div, int *mod)
{
	*div = a / b;
	*mod = a % b;
}
```

**Erros comuns:** calcular `a / b` e depois usar o resultado como
resto. O resto deve ser `a % b` com os **valores originais**.

---

## ex04 — `ft_ultimate_div_mod`

**Protótipo:** `void ft_ultimate_div_mod(int *a, int *b);`

**Objetivo:** colocar em `*a` o quociente de `*a / *b` e em `*b`
o resto dessa mesma divisão.

**Ideia:** guarde `*a` e `*b` antes de alterar para não perder dados.

### Gabarito
```c
// ex04/ft_ultimate_div_mod.c
void	ft_ultimate_div_mod(int *a, int *b)
{
	int x;
	int y;

	x = *a;
	y = *b;
	*a = x / y;
	*b = x % y;
}
```

**Erros comuns:** fazer primeiro `*a = *a / *b;` e depois usar `*a`
modificado para calcular o resto. Isso quebra o resultado.

---

## ex05 — `ft_putstr`

**Protótipo:** `void ft_putstr(char *str);`

**Funções permitidas:** `write` (precisa de `<unistd.h>`)

**Objetivo:** imprimir a string até `\0`.

### Gabarito
```c
// ex05/ft_putstr.c
#include <unistd.h>

void	ft_putstr(char *str)
{
	int i;

	i = 0;
	while (str[i] != '\0')
	{
		write(1, &str[i], 1);
		i++;
	}
}
```

**Erros comuns:** usar `printf` (não permitido) ou não parar no `\0`.

---

## ex06 — `ft_strlen`

**Protótipo:** `int ft_strlen(char *str);`

**Objetivo:** contar quantos caracteres existem antes do `\0`.

### Gabarito
```c
// ex06/ft_strlen.c
int	ft_strlen(char *str)
{
	int len;

	len = 0;
	while (str[len] != '\0')
		len++;
	return (len);
}
```

**Erros comuns:** iniciar `len` sem zero ou retornar `len + 1`.

---

## ex07 — `ft_rev_int_tab`

**Protótipo:** `void ft_rev_int_tab(int *tab, int size);`

**Objetivo:** inverter a ordem dos elementos do array `tab` in-place.

**Ideia:** dois índices, um no começo e outro no fim, trocando até se
cruzarem.

### Gabarito
```c
// ex07/ft_rev_int_tab.c
void	ft_rev_int_tab(int *tab, int size)
{
	int i;
	int j;
	int tmp;

	i = 0;
	j = size - 1;
	while (i < j)
	{
		tmp = tab[i];
		tab[i] = tab[j];
		tab[j] = tmp;
		i++;
		j--;
	}
}
```

**Erros comuns:** laço indo até `i <= j` (troca o elemento central
 duas vezes em tamanhos ímpares) ou esquecer de decrementar `j`.

---

## ex08 — `ft_sort_int_tab`

**Protótipo:** `void ft_sort_int_tab(int *tab, int size);`

**Objetivo:** ordenar o array de inteiros em ordem crescente.

**Estratégia simples (ok para a Piscine):** *bubble sort*.

### Gabarito
```c
// ex08/ft_sort_int_tab.c
void	ft_sort_int_tab(int *tab, int size)
{
	int i;
	int swapped;
	int tmp;

	if (size <= 1)
		return ;
	while (1)
	{
		swapped = 0;
		i = 0;
		while (i < size - 1)
		{
			if (tab[i] > tab[i + 1])
			{
				tmp = tab[i];
				tab[i] = tab[i + 1];
				tab[i + 1] = tmp;
				swapped = 1;
			}
			i++;
		}
		if (!swapped)
			break ;
	}
}
```

**Erros comuns:** confiar que `size` sempre é válido (teste `size <= 1`)
 e esquecer de repetir as passagens até não haver trocas.

---

## Como testar (opcional)

> Estes `main_*.c` são **apenas** para teste local. **Não** envie
> esses arquivos para a 42. Compile cada exercício com o seu
> respectivo `main_exXX.c`.

### ex00 — `ft_ft`
```c
// main_ex00.c
#include <unistd.h>

void	ft_ft(int *nbr);

int	main(void)
{
	int	x = 0;

	ft_ft(&x);
	if (x == 42)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex00/ft_ft.c main_ex00.c -o ex00 && ./ex00
```

### ex01 — `ft_ultimate_ft`
```c
// main_ex01.c
#include <unistd.h>

void	ft_ultimate_ft(int *********nbr);

int	main(void)
{
	int	 n = 0;
	int	*p1 = &n;
	int	**p2 = &p1;
	int	***p3 = &p2;
	int	****p4 = &p3;
	int	*****p5 = &p4;
	int	******p6 = &p5;
	int	*******p7 = &p6;
	int	********p8 = &p7;
	int	*********p9 = &p8;

	ft_ultimate_ft(p9);
	if (n == 42)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex01/ft_ultimate_ft.c main_ex01.c -o ex01 && ./ex01
```

### ex02 — `ft_swap`
```c
// main_ex02.c
#include <unistd.h>

void	ft_swap(int *a, int *b);

int	main(void)
{
	int	a = 1;
	int	b = 2;

	ft_swap(&a, &b);
	if (a == 2 && b == 1)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex02/ft_swap.c main_ex02.c -o ex02 && ./ex02
```

### ex03 — `ft_div_mod`
```c
// main_ex03.c
#include <unistd.h>

void	ft_div_mod(int a, int b, int *div, int *mod);

int	main(void)
{
	int	d;
	int	m;

	ft_div_mod(10, 3, &d, &m);
	if (d == 3 && m == 1)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex03/ft_div_mod.c main_ex03.c -o ex03 && ./ex03
```

### ex04 — `ft_ultimate_div_mod`
```c
// main_ex04.c
#include <unistd.h>

void	ft_ultimate_div_mod(int *a, int *b);

int	main(void)
{
	int	a = 10;
	int	b = 3;

	ft_ultimate_div_mod(&a, &b);
	if (a == 3 && b == 1)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex04/ft_ultimate_div_mod.c main_ex04.c -o ex04 && ./ex04
```

### ex05 — `ft_putstr`
```c
// main_ex05.c
#include <unistd.h>

void	ft_putstr(char *str);

int	main(void)
{
	ft_putstr("Hello");
	write(1, "\n", 1);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex05/ft_putstr.c main_ex05.c -o ex05 && ./ex05
```

### ex06 — `ft_strlen`
```c
// main_ex06.c
#include <unistd.h>

int	ft_strlen(char *str);

int	main(void)
{
	int	len = ft_strlen("abcd");

	if (len == 4)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex06/ft_strlen.c main_ex06.c -o ex06 && ./ex06
```

### ex07 — `ft_rev_int_tab`
```c
// main_ex07.c
#include <unistd.h>

void	ft_rev_int_tab(int *tab, int size);

int	main(void)
{
	int	v[5] = {1, 2, 3, 4, 5};
	int	exp[5] = {5, 4, 3, 2, 1};
	int	i = 0;
	int	ok = 1;

	ft_rev_int_tab(v, 5);
	while (i < 5)
	{
		if (v[i] != exp[i])
			ok = 0;
		i++;
	}
	if (ok)
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex07/ft_rev_int_tab.c main_ex07.c -o ex07 && ./ex07
```

### ex08 — `ft_sort_int_tab`
```c
// main_ex08.c
#include <unistd.h>

void	ft_sort_int_tab(int *tab, int size);

static int	is_sorted(int *v, int n)
{
	int i = 0;
	while (i < n - 1)
	{
		if (v[i] > v[i + 1])
			return (0);
		i++;
	}
	return (1);
}

int	main(void)
{
	int	v[5] = {5, 2, 4, 1, 3};

	ft_sort_int_tab(v, 5);
	if (is_sorted(v, 5))
		write(1, "OK\n", 3);
	else
		write(1, "KO\n", 3);
	return (0);
}
```
**Compilar:**
```bash
gcc -Wall -Wextra -Werror ex08/ft_sort_int_tab.c main_ex08.c -o ex08 && ./ex08
```

---

## Dicas finais

- Crie um `main.c` separado só para seus testes locais.
- Teste casos limite: `size = 0`, `size = 1`, strings vazias, números
  negativos etc.
- Revise identação, tabulações e nomes conforme a Norm da 42.
- Se o avaliador citar funções proibidas, remova qualquer `#include`
  desnecessário.
