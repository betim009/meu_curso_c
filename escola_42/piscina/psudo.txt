### ft_print_comb2.c
início
  definir a como 0
  enquanto a <= 98
    definir b como a + 1
    enquanto b <= 99
      imprimir a com 2 dígitos
      imprimir espaço
      imprimir b com 2 dígitos
      se não for a última combinação
        imprimir ", "
      incrementar b
    incrementar a
fim

#### Processo (exemplo)
entrada: sem entrada
passo 1: a=0, b=1 → imprime "00 01"
passo 2: b sobe: ... "00 98", "00 99"
passo 3: a sobe: a=1, b=2 → "01 02" ... "01 99"
passo 4: repete até a=98, b=99
fim: última saída é "98 99"

### ft_strlen.c
início
  definir i como 0
  enquanto caractere na posição i não for '\0'
    incrementar i
  retornar i
fim

#### Processo (exemplo)
entrada: "Hello"
passo 1: i=0 ('H')
passo 2: i=1 ('e')
passo 3: i=2 ('l')
passo 4: i=3 ('l')
passo 5: i=4 ('o')
passo 6: i=5 ('\0') → para
retorno: 5

### ft_swap.c
início
  definir temp como valor de a
  atribuir a o valor de b
  atribuir b o valor de temp
fim

#### Processo (exemplo)
entrada: a=3, b=5
passo 1: temp=3
passo 2: a=5
passo 3: b=3
resultado: a=5, b=3

### rev_print.c
início
  definir i como 0
  enquanto caractere na posição i existir
    incrementar i
  definir last como i - 1
  enquanto last >= 0
    imprimir caractere na posição last
    decrementar last
  imprimir '\n'
fim

#### Processo (exemplo)
entrada: "abc"
passo 1: len=3 → last=2
passo 2: imprime 'c' (last=1)
passo 3: imprime 'b' (last=0)
passo 4: imprime 'a' (last=-1)
passo 5: imprime '\n'
saída: cba\n

### first_word.c
início
  definir i como 0
  enquanto caractere na posição i for espaço ou tab
    incrementar i
  enquanto caractere na posição i existir e não for espaço ou tab
    imprimir caractere na posição i
    incrementar i
  imprimir '\n'
fim

#### Processo (exemplo)
entrada: "   hello  world"
passo 1: pula espaços até 'h'
passo 2: imprime 'h','e','l','l','o'
passo 3: para no espaço
passo 4: imprime '\n'
saída: hello\n

### ft_strrev.c
início
  definir i como 0
  enquanto caractere na posição i existir
    incrementar i
  definir last como i - 1
  definir i como 0
  enquanto i < last
    trocar caractere na posição i com caractere na posição last
    incrementar i
    decrementar last
  retornar string
fim

#### Processo (exemplo)
entrada: "abcd"
passo 1: len=4 → i=0, last=3
passo 2: troca [0]<->[3] → "dbca"
passo 3: i=1,last=2 troca → "dcba"
passo 4: i=2,last=1 → para
retorno: "dcba"

### rot_13.c
início
  para cada caractere c na string
    se c entre 'A' e 'M' ou entre 'a' e 'm'
      substituir c por c + 13
    senão se c entre 'N' e 'Z' ou entre 'n' e 'z'
      substituir c por c - 13
    imprimir c
  imprimir '\n'
fim

#### Processo (exemplo)
entrada: "Hello"
passo 1: H→U
passo 2: e→r
passo 3: l→y
passo 4: l→y
passo 5: o→b
saída: Uryyb\n

### rotone.c
início
  para cada caractere c na string
    se c entre 'A' e 'Y' ou entre 'a' e 'y'
      substituir c por c + 1
    senão se c igual a 'Z'
      substituir c por 'A'
    senão se c igual a 'z'
      substituir c por 'a'
    imprimir c
  imprimir '\n'
fim

#### Processo (exemplo)
entrada: "Zoo zebra!"
passo 1: Z→A
passo 2: o→p
passo 3: o→p
passo 4: ' ' fica
passo 5: z→a
passo 6: e→f
passo 7: b→c
passo 8: r→s
passo 9: a→b
passo 10: ! fica
saída: App afcsb!\n

### inter.c
início
  para cada caractere em s1
    se caractere não apareceu antes em s1
      se caractere existe em s2
        imprimir caractere
fim

#### Processo (exemplo)
entrada: s1="apple", s2="peach"
passo 1: 'a' novo e em s2 → imprime 'a'
passo 2: 'p' novo e em s2 → imprime 'p'
passo 3: 'p' repetido → ignora
passo 4: 'l' não está em s2 → ignora
passo 5: 'e' em s2 → imprime 'e'
saída: ape

### last_word.c
início
  definir i como tamanho da string - 1
  enquanto i >= 0 e caractere for espaço ou tab
    decrementar i
  definir fim como i
  enquanto i >= 0 e caractere não for espaço ou tab
    decrementar i
  definir início como i + 1
  para k de início até fim
    imprimir caractere na posição k
  imprimir '\n'
fim

#### Processo (exemplo)
entrada: "  ola   mundo  "
passo 1: vai ao fim e recua espaços
passo 2: marca fim no 'o' de "mundo"
passo 3: recua até espaço antes da palavra
passo 4: início = próxima letra
passo 5: imprime de início a fim → "mundo"
passo 6: imprime '\n'
saída: mundo\n

### union.c
início
  para cada caractere em s1
    se caractere não apareceu antes em s1
      imprimir caractere
  para cada caractere em s2
    se caractere não está em s1 e não apareceu antes em s2
      imprimir caractere
fim

#### Processo (exemplo)
entrada: s1="abc", s2="bcd"
passo 1: de s1: 'a','b','c'
passo 2: de s2: 'b' já tem → pula
passo 3: de s2: 'c' já tem → pula
passo 4: de s2: 'd' novo → imprime
saída: abcd

### wdmatch.c
início
  definir i como 0
  definir j como 0
  enquanto caractere em texto e caractere em alvo
    se caractere em texto igual ao caractere em alvo
      incrementar i
    incrementar j
  se alvo terminou
    imprimir alvo
  imprimir '\n'
fim

#### Processo (exemplo)
entrada: alvo="abc", texto="a1b2c3"
passo 1: acha 'a' → i=1
passo 2: acha 'b' → i=2
passo 3: acha 'c' → i=3 (fim do alvo)
passo 4: imprime alvo e '\n'
saída: abc\n

### ft_range.c
início
  calcular size como valor absoluto de (end - start) + 1
  alocar vetor com size posições
  definir atual como start
  para i de 0 até size - 1
    vetor[i] recebe atual
    se start <= end
      incrementar atual
    senão
      decrementar atual
  retornar vetor
fim

#### Processo (exemplo)
entrada: start=3, end=7
passo 1: size=|7-3|+1=5
passo 2: preenche: 3,4,5,6,7
retorno: [3,4,5,6,7]

### ft_itoa.c
início
  converter n para long nb
  calcular len com função de casas decimais
  alocar string com len + 1 posições
  se nb == 0
    string[0] = '0'
    retornar string
  se nb < 0
    marcar sinal
    nb = -nb
  preencher string do fim para o início com dígitos de nb
  se sinal marcado
    string[0] = '-'
  retornar string
fim

#### Processo (exemplo)
entrada: n=-120
passo 1: len=4 (sinal + 3 dígitos)
passo 2: preencher de trás: '0','2','1'
passo 3: sinal '-' na frente
retorno: "-120"

### ft_split.c
início
  contar palavras separadas por caracteres do charset
  alocar vetor de palavras
  para cada caractere em str
    se for separador
      pular
    senão
      extrair palavra até próximo separador
      adicionar palavra ao vetor
  vetor termina com NULL
  retornar vetor
fim

#### Processo (exemplo)
entrada: str="Words to.be/splitted*in@six"
charset: "./*@! "
passo 1: conta 6 palavras
passo 2: extrai "Words"
passo 3: extrai "to"
passo 4: extrai "be"
passo 5: extrai "splitted"
passo 6: extrai "in"
passo 7: extrai "six"
retorno: ["Words","to","be","splitted","in","six",NULL]